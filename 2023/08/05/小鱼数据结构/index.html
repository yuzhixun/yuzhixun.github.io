
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8" />
        <title>小鱼数据库 | Argvchs の小窝</title>
        <meta name="author" content="Argvchs" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar1.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>ARGVCHS の小窝</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ARGVCHS の小窝</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>小鱼数据库</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/5
        </span>
        
        <span class="category">
            <a href="/categories/%E6%8A%80%E6%9C%AF/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                技术
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Typora/" style="color: #ffa2c4">Typora</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Markdown/" style="color: #00a596">Markdown</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/vscode/" style="color: #03a9f4">vscode</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p><strong>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科</strong></p>
<blockquote>
<p>我们也可以说<br>程序设计 &#x3D; 数据结构 + 算法</p>
</blockquote>
<h2 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h2><p>数据结构分为</p>
<pre><code class="mermaid">graph TD;
    程序设计--&gt;逻辑结构;
    程序设计--&gt;物理结构;
    逻辑结构--&gt;集合结构;
    逻辑结构--&gt;线性结构;
    逻辑结构--&gt;树状结构;
    逻辑结构--&gt;图形结构;
    物理结构--&gt;顺序存储结构;
    物理结构--&gt;链式存储结构;
</code></pre>
<h2 id="谈谈算法"><a href="#谈谈算法" class="headerlink" title="谈谈算法"></a>谈谈算法</h2><p> 算法具有五个特征：</p>
<ol>
<li>输入</li>
<li>输出</li>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
</ol>
<blockquote>
<p><strong>算法具有零个或多个输入。</strong></p>
</blockquote>
<blockquote>
<p><strong>算法至少有一个或多个输出。</strong></p>
<p><strong>算法一定要输出，可以返回一个值或多个值</strong></p>
</blockquote>
<blockquote>
<p><strong>指算法在执行有限的步骤后，自动结束而不会无限循环</strong></p>
</blockquote>
<blockquote>
<p><strong>算法的每一个步骤都有确定的含义，不会出现二义性</strong></p>
</blockquote>
<blockquote>
<p><strong>算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</strong></p>
</blockquote>
<p><strong>算法不是唯一的，一个题有多种解决方法</strong></p>
<h2 id="计算算法复杂度"><a href="#计算算法复杂度" class="headerlink" title="计算算法复杂度"></a>计算算法复杂度</h2><p>算法的时间复杂度是用来衡量算法执行时间随输入规模增长而增长的速度。它描述了算法的时间消耗和输入规模之间的关系。</p>
<p><strong>在计算时间复杂度时，通常考虑算法中基本操作的执行次数，并用大O表示法来表示时间复杂度。大O表示法表示算法最坏情况下的时间复杂度上界。</strong></p>
<p>以下是常见的时间复杂度：</p>
<ol>
<li>常数时间复杂度（O(1)）：无论输入规模如何增长，算法的执行时间都保持不变。例如，访问数组中的特定元素。</li>
<li>对数时间复杂度（O(log n)）：随着输入规模的增长，算法的执行时间以对数方式增加。例如，二分查找算法。</li>
</ol>
<pre><code class="c">while(i &lt; 100)&#123;
    i = i * 2;
&#125;
</code></pre>
<ol start="3">
<li>线性时间复杂度（O(n)）：算法的执行时间与输入规模成线性关系。例如，遍历一个数组。</li>
<li>线性对数时间复杂度（O(n log n)）：算法的执行时间与输入规模成线性对数关系。例如，快速排序算法、归并排序算法</li>
<li>平方时间复杂度（O(n^2)）：算法的执行时间与输入规模的平方成正比。例如，嵌套循环遍历一个二维数组。</li>
<li>指数时间复杂度（O(2^n)）：算法的执行时间随着输入规模呈指数级增长。例如，求解旅行商问题的暴力穷举算法。</li>
</ol>
<p>需要注意的是，时间复杂度只关注算法执行时间与输入规模之间的增长趋势，而不关注具体的执行时间。同时，算法中可能存在多个操作或分支，时间复杂度描述的是算法整体的时间消耗。</p>
<blockquote>
<p><strong>平方时间复杂度（O(n^2)）</strong></p>
</blockquote>
<pre><code class="c">int i ,j,n = 100;
for(i = 0;i&lt;n;i++)&#123;
    for(j = i;j&lt;n;j++)&#123;
        printf(&quot;woshinidie&quot;);	
    &#125;
&#125;
</code></pre>
<p>以上代码我们如何求平方阶<br><strong>n+n-1+n-2+n-3+………1&#x3D;?&#x3D;n(n+1)&#x2F;2</strong><br>第一步去掉常数项没有常数，我们省略这一步；<br>第二步去掉除了最高阶以外的阶，变成了n^2&#x2F;2;<br><strong>第三步去掉最高阶项的常数，变成n^2;</strong></p>
<p><img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-05_22-50-01.png" alt="Snipaste_2023-09-05_22-50-01"></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表的特性：像排队一样，具有线一样的性质</p>
<blockquote>
<p><strong>什么是线性表呢</strong>？</p>
<p><strong>线性表是给人看的，不是给机器看的</strong></p>
</blockquote>
<p>由零个或多个数据元素组成的有限序列。</p>
<p>需要强调几个地方：</p>
<ol>
<li>线性表是一个序列，也就是说有个先来后到的特点</li>
<li>线性表的处理元素时有限的。</li>
<li>线性表允许为空表，也就是元素为零。</li>
</ol>
<p><strong>这句话的意思是，线性表中有四个元素，分别是1，2，3，4.</strong></p>
<p>我们用简单的数学来定义：</p>
<p><img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-07_21-55-29.png" alt="Snipaste_2023-09-07_21-55-29"></p>
<p><strong>如上图所示，ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素</strong></p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</strong></p>
<pre><code class="mermaid">graph LR
    数据类型 --&gt; 原子类型
    数据类型 --&gt; 结构类型
</code></pre>
<p>原子类型：不可再分解<br>结构类型：可在分解。<strong>例如：整型数组是由若干整型数据组成的</strong></p>
<p><strong>抽象数据类型（Abstract Data Type，简称ADT）</strong>是一种计算机科学中的概念，用于描述数据结构的逻辑特性和操作。它定义了一个数据类型的抽象模型，包括数据的组织方式和可执行的操作，而不需关注具体的实现细节。</p>
<h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性表的抽象数据类型的定义：<br>ATD 线性表（list）<br>Date：线性表的数据对象集合为{a1,a2,a3,a4…..,an}，每一个元素的类型均为DateType。其中，除第一个元素a1外，每一个元素只有一个直接前驱元素，除了最后一个元素，每一个元素只有一个直接后继元素。<br>operation：<br>Initlist(*L):初始化操作，家里一个空的线性表L。<br>ListEmpty(L)：判断线性表是否为空表，若为空表返回true，反则false。<br>ClearList(*L):将列表清空。<br>GetElem(L,i,*e):将线性表L中的第i个位置的元素值返回给e。<br>ListInsert(*L,i,e):在线性表L中第i个位置插入新元素e。<br>ListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值。<br>ListLength(L):返回线性表L的元素个数。</p>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><pre><code class="c">#define MAXSIZE 20;
typedef int ElemType;
typedef struct&#123;
    ElemType date[MAXSIZE];
    int length;    	//线性表当前的长度
&#125;splist;
</code></pre>
<p>顺序的存储表结构的封装需要三个属性</p>
<ol>
<li>存储空间的起始位置，数组date，他的存储位置就是线性表存储空间的存储位置。</li>
<li>线性表的最大存储容量：数组的长度MaxSize。</li>
<li>线性表的当前长度：length。</li>
</ol>
<blockquote>
<p><strong>注意，数组与线性表的区别主要是，数组的长度一旦规定，就不能随意更改，而线性表的长度是线性表中现有元素的个数，是会改变的。线性表是给人看的，不是给机器看的</strong></p>
</blockquote>
<p>假设ElemType占用c个字节，那我们可以用这样的一个关系式来表达顺序结构之间的关系：<strong>LOC(Ai+1) &#x3D; LOC(Ai)  + c;</strong><br><strong>LOC(Ai) &#x3D; LOC(1)  + (i-1)*c;</strong></p>
<h3 id="获取元素的操作："><a href="#获取元素的操作：" class="headerlink" title="获取元素的操作："></a>获取元素的操作：</h3><pre><code class="c">#include &lt;stdio.h&gt;

#define MAX_SIZE 100   // 假设线性表的最大长度为100

typedef int ElemType;  // 假设线性表中的元素类型为整数

typedef struct &#123;
    ElemType data[MAX_SIZE];  // 用数组存储线性表的元素
    int length;               // 记录线性表的当前长度
&#125; List;

int GetElem(List L, int i, ElemType *e);

int main() &#123;
    
    ElemType e = 0;
    
    // 获取线性表 L 中的第 2 个元素
    if(GetElem(L, 2, &amp;e)) &#123;
        printf(&quot;线性表 L 中的第 2 个元素是: %d\n&quot;, e);
    &#125; else &#123;
        printf(&quot;获取元素失败！\n&quot;);
    &#125;
    
    return 0;
&#125;

int GetElem(List L, int i, ElemType *e) &#123;
    if (i &lt; 1 || i &gt; L.length) &#123;   // 判断下标是否越界
        return 0;
    &#125;
    
    *e = L.data[i - 1];   // 获取元素的值
    
    return 1;
&#125;
</code></pre>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p><strong>从最后一个元素开始</strong></p>
<pre><code class="c">// 在线性表 L 的第 i 个位置插入新元素 e
int ListInsert(List* L, int i, ElemType e) &#123;
    // 判断线性表是否已满
    if (L-&gt;length &gt;= MAX_SIZE) &#123;
        return ERROR;  // 线性表已满，返回错误信息
    &#125;
    
    // 判断插入位置是否合法
    if (i &lt; 1 || i &gt; L-&gt;length+1) &#123;
        return ERROR;  // 插入位置非法，返回错误信息
    &#125;
    
    // 将插入位置 i 和之后的元素向后移动一位
    for (int j = L-&gt;length-1; j &gt;= i-1; j--) &#123;
        L-&gt;data[j+1] = L-&gt;data[j];
    &#125;
    
    // 插入新元素并更新线性表长度
    L-&gt;data[i-1] = e;
    L-&gt;length++;
    
    return OK;  // 插入成功，返回 OK
&#125;
</code></pre>
<p><strong>要注意，数组的和线性表要区分开来，线性表里的1是数组里的0，也就是线性表里的n是数组里的n-1;</strong></p>
<p><strong>还有就是数组是线性表里的一个子集，线性表就是一个架构，里面包含了数据，还有长度</strong></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除的思路：<br><strong>去除删除的元素，从删除的元素位置开始遍历到最后一个元素的位置，分别将他们都向前移动一个位置；</strong></p>
<pre><code class="c">// 在线性表 L 的第 i 个位置插入新元素 e
int ListDelete(List* L, int i, ElemType e) &#123;
    int k;
    // 判断线性表是否已满
    if (L-&gt;length == 0) &#123;
        return ERROR;  // 线性表已满，返回错误信息
    &#125;
    
    // 判断插入位置是否合法
    if (i &lt; 1 || i &gt; L-&gt;length+1) &#123;
        return ERROR;  // 插入位置非法，返回错误信息
    &#125;
    
    // 将插入位置 i 和之后的元素向后移动一位
    for (k = i;k &lt; L-&gt;length;k++) &#123;
        L-&gt;data[k-1] = L-&gt;data[k];
    &#125;
    
    // 插入新元素并更新线性表长度
    L-&gt;length--;
    
    return OK;  // 插入成功，返回 OK
&#125;
</code></pre>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>​		<strong>线性表的链式存储结构的特点是用一组任意的存储单元线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。</strong></p>
<blockquote>
<p><em><strong>也就是说每一个存储位置都包含一个数据以及一个指针</strong></em>，这个存储位置我们形象的称为<strong>节点</strong></p>
</blockquote>
<p><img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-11_10-57-36.png" alt="Snipaste_2023-09-11_10-57-36"></p>
<p>线性表中的第一个节点称为头节点，最后一个节点称为NULL</p>
<h3 id="头指针与头节点的异同"><a href="#头指针与头节点的异同" class="headerlink" title="头指针与头节点的异同"></a>头指针与头节点的异同</h3><p>在链表中，头指针（Head Pointer）和头节点（Head Node）是两个不同的概念。</p>
<p><strong>头指针</strong>是指向链表中第一个节点的指针。它是一个指针变量，<strong>存储了链表中第一个节点的内存地址</strong>。使用头指针，我们可以遍历整个链表，访问和操作链表中的每个节点。</p>
<p><strong>头节点</strong>是一个特殊的节点，位于链表的开头，<strong>并且不存储具体的数据</strong>。头节点的作用是提供一个统一的入口，方便对链表进行操作。在某些链表实现中，头节点可能存储链表的长度等附加信息。</p>
<p><strong>头指针和头节点的关系通常是：头指针指向头节点。通过头指针，我们可以访问到头节点，进而遍历整个链表。</strong></p>
<p>需要注意的是，在某些情况下，头节点也可以是第一个真实存储数据的节点（即功能上同时充当头节点和首个数据节点），而没有额外的头指针。</p>
<p>总结来说：</p>
<ul>
<li>头指针是指向链表中第一个节点的指针变量。</li>
<li>头节点是链表中的一个特殊节点，位于链表开头，不存储具体数据，用于提供一个统一的入口。</li>
</ul>
<p>这些概念在不同的链表实现和编程语言中可能有所不同，但通常遵循这个基本的概念。</p>
<blockquote>
<p><strong>这是个单链表</strong></p>
</blockquote>
<p><img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-11_11-07-30.png" alt="Snipaste_2023-09-11_11-07-30"></p>
<p>单链表是一种链式存储结构，由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。单链表的存储结构可以用以下代码实现：</p>
<pre><code class="c">typedef struct Node&#123;
    int data;             // 数据域
    struct Node *next;    // 指针域
&#125;Node, *LinkedList;
</code></pre>
<p>其中，Node代表一个节点，LinkedList则是一个指向节点的指针。在单链表中，我们通常采用头指针来表示整个链表，它指向第一个节点。如果链表为空，则头指针为NULL。</p>
<p>需要注意的是，<strong>单链表没有直接访问任意位置的能力，只能从头指针开始沿着链表逐个遍历，直到找到所需位置的节点</strong>。因此，在进行插入、删除等操作时，需要先找到要操作的节点的前一个节点。</p>
<h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><ul>
<li>​	获得链表第i个数据的算法思路：<ul>
<li>声明一个节点p指向链表第一个节点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j+1；</li>
<li>若到链表末尾p为空，则说明第i元素不存在；</li>
<li>若则查找成功，返回节点p的数据。</li>
</ul>
</li>
</ul>
<pre><code class="c">Status GetElem(Linklist L,int i,Elemtype *e)&#123;
    LinkList p = L-&gt;next;
    int j = 1;
    
    while(p &amp;&amp; j&lt;i)&#123;
        p = p-&gt;next;
        j++;
    &#125;
    
    if(!p || j &gt; i)&#123;
        return error;
    &#125;
    
    *e = p-&gt;data;
    return ok;
&#125;
</code></pre>
<h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>这个位置的逻辑其实很简单，我们把节点s安置在p和p-&gt;next的中间，也就是说，我们把原来的p-&gt;next赋值给现在的s-&gt;next，然后把现有的s赋值给前面的p-&gt;next;</p>
<p><img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-12_22-04-46.png" alt="Snipaste_2023-09-12_22-04-46"></p>
<p><strong>操作</strong>：</p>
<ol>
<li>声明一节点p指向链表头节点，初始化j从一开始；</li>
<li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一节点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，在系统中生成一个空节点s；</li>
<li>将数据元素e赋值给s-&gt;date；</li>
<li>单链表的插入刚才两个标准语句；</li>
<li>返回成功</li>
</ol>
<pre><code class="c">Status listInsert(linklist *L,int i,ElemType e)&#123;
    int j;
    Linklist p,s;
    
    p = *L;
    j = 1;
    
    while(p &amp;&amp; j&lt;i)&#123;
        p = p-&gt;next;
        j++;
    &#125;
    
    if(!p || j&gt;i)&#123;
        return ERROR;
    &#125;
    
    s = (LinkList)malloc(sizeof(Node));
    s-&gt;date = e;
    s-&gt;next = p-&gt;next;
    p-&gt;next = s;

    return OK;
&#125;

/*s-&gt;next = p-&gt;next;
    p-&gt;next = s;
*/这个顺序我们是不能随便替换的
</code></pre>
<h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p> 顾名思义，其实就是将p-&gt;next &#x3D; p-&gt;next-&gt;next;</p>
<pre><code class="c">Status listInsert(linklist *L,int i,ElemType *e)&#123;
    int j;
    Linklist p,q;
    
    p = *L;
    j = 1;
    
    while(p-&gt;next &amp;&amp; j&lt;i)&#123;
        p = p-&gt;next;
        j++;
    &#125;
    
    if(!(p-&gt;next) || j&gt;i)&#123;
        return ERROR;
    &#125;
       q = p-&gt;next;
    p-&gt;next = q-&gt;next;
    *e = q-&gt;data;
    free(q);
    return OK;
&#125;
</code></pre>
<h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>单链表的创建并不是直接给定你大小，而是在之后的循环当中去决定，<strong>单链表一开始是从初始的空表状态，依次建立各个元素节点并逐个插入链表。</strong></p>
<ul>
<li>单链表的创建算法思路如下：<ul>
<li>声明一节点p和计数器变量i；</li>
<li>初始化一空链表；</li>
<li>让L的头节点的指针指向NULL，及建立一个带头节点的单链表；</li>
<li>循环实现后继节点的赋值和插入；</li>
</ul>
</li>
</ul>
<h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><p>​		<strong>使用头插法创建单链表是一种常见的方式，它可以将新节点插入到链表的头部，创建一个逆序的链表。</strong></p>
<pre><code class="c">Node* CreateLinkedList(int arr[], int size) &#123;
    Node* head = NULL;

    for (int i = 0; i &lt; size; i++) &#123;
        Node* newNode = (Node*)malloc(sizeof(Node));
        newNode-&gt;data = arr[i];
        newNode-&gt;next = head;
        head = newNode;
    &#125;

    return head;
&#125;
</code></pre>
<h3 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h3><p>​		<strong>头插法的缺点也很明晰，头插法属于顺序相反的插法</strong></p>
<pre><code class="c">void CreateListTail(Linklist *L,int n)&#123;
    LinkList p,r;
    int i;
    
    srand(time(0));
    *L = (LinkList)malloc(sizeof(Node));
    r = *L;
    
    for(i=0;i&lt;n;i++)&#123;
        p = (Node *)malloc(sizeof(Node));
        p-&gt;data = rand()%100+1;
        r-&gt;next = p;
        r = p;
    &#125;
    
    r-&gt;next = NULL;
    
&#125;
</code></pre>
<h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><p>​		单链表的删除其实就是在内存中将它释放：</p>
<ol>
<li>声明节点p和q。</li>
<li>将第一个节点赋值给p，下一个节点赋值给q。</li>
<li>循环执行释放p和将q赋值给p的操作。</li>
</ol>
<pre><code class="c">Status ClearList(LinkList *L)&#123;
    LinkList p,q;
    p = (*L)-&gt;next;
    
    while(p)&#123;
        q = p-&gt;next;
        free(p);
        p = q;
    &#125;
    (*L)-&gt;next = NULL;
    
    return OK;
&#125;
</code></pre>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p><strong>循环，顾名思义就是：绕。</strong></p>
<p><strong>单链表的问题非常明显， 不从头节点开始，我们就无法访问到所有的节点。</strong></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node&#123;
    int data;
    struct Node* next;
&#125;;

struct Node* createCircularLinkedList(int data[],int length)&#123;
    if(length == 0)&#123;
        return NULL;
    &#125;
    
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    head-&gt;data = data[0];
    head-&gt;next = NULL;

    struct Node* current = head;

    for(int i = 1;i &lt; length;i++)&#123;
    struct Node* newNode = (struct node*)malloc(sizeof(struct Node));
    newNode-&gt;data = data[i];
    new-&gt;next = NULL;
    
    current-&gt;next = newNode;
    current = newNode;
    &#125;

    current-&gt;next = head;
    
    return head;
&#125;

void printCircularLinkedList(struct Node* head)&#123;
    if(head == Null)&#123;
        printf(&quot;Empty list.\n&quot;);
        return;
    &#125;
    
    struct Node* current = head;
    
    do&#123;
        print(&quot;%d-&gt;&quot;,current-&gt;data);
        current = current-&gt;next;
    &#125;while(current != head);
    
    printf(&quot;....\n&quot;);
&#125;

int main() &#123;
    int data[] = &#123;1, 2, 3, 4, 5&#125;;
    int length = sizeof(data) / sizeof(data[0]);

    struct Node* head = createCircularLinkedList(data, length);

    printCircularLinkedList(head);

    return 0;
&#125;
</code></pre>
<p>单循环链表的问题有很大，比如，我们基本是寻求第n个节点，这样的话，我们们时间复杂度就成了O（n)，大大降低了运行效率。</p>
<blockquote>
<p><strong>用尾指针表示单循环的链表</strong>：</p>
<ol>
<li>a1的存储位置是：R-&gt;next-&gt;next  </li>
<li>an的存储位置是：R</li>
</ol>
</blockquote>
<p> <img src="https://typora200483.oss-cn-chengdu.aliyuncs.com/Snipaste_2023-09-19_16-53-57.png" alt="Snipaste_2023-09-19_16-53-57"></p>
<pre><code class="c">
</code></pre>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈可以说是线性表的具体结构</strong></p>
<p><strong>栈中的数据是先进后出 ，后进先出，只要求在表尾，或者表头进行插入和删除</strong></p>
<p><strong>最开始栈中没有任何元素，此时，栈顶就是栈底，此时的栈就是“空栈”</strong></p>
<h3 id="定义一个栈"><a href="#定义一个栈" class="headerlink" title="定义一个栈"></a>定义一个栈</h3><pre><code class="c">typedef struct&#123;
    SElemtype *base;
    SElemtype *top;
    int stackSize;
&#125;sqStack;
</code></pre>
<h3 id="创建一个栈"><a href="#创建一个栈" class="headerlink" title="创建一个栈"></a>创建一个栈</h3><pre><code class="c">#define STACK_INIT_SIZE 100

initStack(sqStack *s)&#123;
    s-&gt;base = (SElemtype *)malloc(STACK_INIT_SIZE * sizeof(SElemtype));
    if(!s-&gt;base)esit(0);
    s-&gt;top = s-&gt;base;
    s-&gt;stackSize = STACK_INIT_SIZE;
&#125;
</code></pre>
<h3 id="入栈操作"><a href="#入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><pre><code class="c">#define SATCKINCREMENT 10

Push(sqStack *s,Elemtype e)&#123;
    if(s-&gt;top - s-&gt;base &gt;= STACK_INIT_SIZE)&#123;
        s-&gt;base = (SElemtype *)realloc((STACK_INIT_SIZE + SATCKINCREMENT)* sizeof(SElemtype));
    &#125;
&#125;
</code></pre>
<h3 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><ul>
<li><code>Pop(S, &amp;x)</code> 将栈顶元素出栈并赋值给变量 x，此时 x 的值为 ‘k’。<br>  <strong>要记住pop一定是出栈顶元素，不会是找到栈表中的x，然后将其删除，而是删除栈顶元素，然后将删除的值赋值给变量x，让其继续延续下去</strong></li>
</ul>
<pre><code class="c">void main()&#123;
    Stack S;
    char x,y;
    InitStack(S);
    x=&#39;c&#39;;y=&#39;k&#39;;
    Push(S,x);Push(S,&#39;a&#39;);Push(S,y);
    Pop(S,x);Pop(S,&#39;t&#39;);Push(S,x);
    Pop(S,x);Push(S,&#39;s&#39;);
    while(!StackEmpty(S))&#123;Pop(S,y);pritnf(y);&#125;;
    printf(x);
&#125;
</code></pre>
<p><strong>这个实例就运用了出栈和入栈操作，以及如何将栈里的元素一个一个输出出来</strong></p>
<p><strong>结果就是stack</strong></p>
<h2 id="对列"><a href="#对列" class="headerlink" title="对列"></a>对列</h2><p>长话短说，其实和栈差不多。<br>这里举一个进队和出队的一个例子</p>
<pre><code class="c">void main()&#123;
    Queue Q;InitQueue(Q);
    char x = &#39;e&#39;,y = &#39;c&#39;;
    EnQueue(Q,&#39;h&#39;);Enqueue(Q,&#39;r&#39;);Enqueue(Q,y);
    DeQueue(Q,x);EeQueue(Q,x);
    DeQueue(Q,x);EeQueue(Q,&#39;a&#39;);
    while(!QueueEmpyt(Q))&#123;
        DeQueue(Q,y);
        printf(y);
    &#125;
    printf(x);
&#125;
</code></pre>
<p><strong>结果就是char</strong></p>
<h1 id="易错点分析"><a href="#易错点分析" class="headerlink" title="易错点分析"></a>易错点分析</h1><h2 id="在创建结构体当中，我们需要注意"><a href="#在创建结构体当中，我们需要注意" class="headerlink" title="在创建结构体当中，我们需要注意"></a>在创建结构体当中，我们需要注意</h2><pre><code class="c">typedef struct LNode&#123;
    elemType data;
    struct LNode *next;
&#125; LNode;

typedef LNode *LinkList;
</code></pre>
<p>上述的写法实际上也是下面的写法</p>
<pre><code class="c">typedef struct LNode&#123;
    elemType data;
    struct LNode *next;
&#125;LNode,*LinkList
</code></pre>
<p><strong>这里的LNode 实际上是结构体类型并不是指针，而后续的LinkList是这个结构体类型的指针</strong></p>
<h2 id="函数的参数声明"><a href="#函数的参数声明" class="headerlink" title="函数的参数声明"></a>函数的参数声明</h2><p><strong>函数有两种传递形式</strong></p>
<ol>
<li><p>当参数类型为值传递时，函数会在栈上创建一个新的变量副本来存储传入的实参的值。这意味着在函数内部对参数 <code>L</code> 的修改不会影响到原始的链表。</p>
</li>
<li><p>如果你希望在函数内部能够对链表进行修改并影响到原始的链表，可以使用引用类型作为参数。修改函数声明为 <code>void Show(LinkList &amp;L)</code> 就可以实现通过引用传递来修改链表。</p>
</li>
</ol>
<p>需要注意的是，在使用引用类型作为参数时，要确保传入的实参是可修改的（非常量），否则会导致编译错误。</p>
<p>总之，使用值传递或引用传递作为函数参数取决于你的需求，如果需要在函数内部修改链表并影响到原始链表，可以使用引用传递。如果只需要在函数内部读取链表而不修改原始链表，使用值传递即可。</p>
<p>我们举个例子</p>
<pre><code class="c">void SitDown(LNode* &amp;L,int number)
&#123;
    LNode* p;
    L=(LNode*)malloc(sizeof(LNode)); //创建头节点 
    L-&gt;data=1; //头结点的值给为1 
    L-&gt;next=L; // 
    
    for(int i=number;i&gt;=2;i--)
    &#123;
       p=(LNode*)malloc(sizeof(LNode));
       p-&gt;data=i;
       p-&gt;next=L-&gt;next;
       L-&gt;next=p;
    &#125;
&#125;
</code></pre>
<p>以上</p>
<p>在我们在传递参数时，采用了形式传递，<strong>也就是传递地址</strong>，以上我们想要传递一个链表的地址，我写的是<em><em>LNode</em> &amp;L</em><em>,这就如错误一一样，LNode是个结构体类型但是不是指针，而我们要的是L的地址，所以我们写的是&amp;L，进而LNode 要写成LNode</em></p>
<p>或者，我们也可以这样去思考</p>
<pre><code class="c">void SitDown(LinkList &amp;L,int number)
&#123;
    LNode* p;
    L=(LNode*)malloc(sizeof(LNode)); //创建头节点 
    L-&gt;data=1; //头结点的值给为1 
    L-&gt;next=L; // 
    
    for(int i=number;i&gt;=2;i--)
    &#123;
       p=(LNode*)malloc(sizeof(LNode));
       p-&gt;data=i;
       p-&gt;next=L-&gt;next;
       L-&gt;next=p;
    &#125;
&#125;
</code></pre>
<p><strong>上述我们在构建结构体时，已经声明了LinkList是指向结构体类型的指针，所以我们可以直接使用，这样使代码看起来更舒服了</strong></p>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Argvchs の小窝
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Argvchs
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        
        <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src="/js/fireworks.min.js"></script>

        <canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
        <script src="/js/background.min.js"></script>

        <div id="cursor"></div>
        <link rel="stylesheet" href="/css/cursor.min.css" />
        <script src="/js/cursor.min.js"></script>

        <script src="/js/main.js"></script>
        
        




        

        <script src="https://giscus.app/client.js"
            data-repo="yuzhixun/yuzhixun.github.io"
            data-repo-id="R_kgDOJ1fZvw"
            data-category="Announcements"
            data-category-id="DIC_kwDOJ1fZv84CZEy-"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="zh-CN"
            crossorigin="anonymous"
            async>
        </script>

    </body>
</html>
